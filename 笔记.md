深入去思考、对比！这已经是多次看这个视频了

这次把 git 用好

#### 课程四个阶段(对于我的一个新的要求):

1. 第一阶段 用来回顾一下 react 的基础知识(结合 React 文档)，配合 TS 完成一个实验性网站
2. 实现一个标准电商的所需要的基础功能，比如，页面布局、项目架构、路由配置、数据调取、产品浏览等
3. 项目的架构思想、使用 redux 对项目重构、网站的全局状态管理、用户登录、购物车管理、下单结算功能 以及 react 高级用法
4. 前端项目的测试，使用 docker 来完成 react 项目的容器化部署，并使用阿里云完成项目的上线(使用 Docker 是一个项目亮点 需扩展来学习思考)

**带着问题来学习：**

1. **如何启动一个 react 项目？** npx create-react-app my-app
2. **如何启动一个 TS 版本的 React 项目？** npx create-react-app my-app --template typescript
3. **create-react-app 是什么？** 一个 react 的脚手架, 内置了 webpack
4. **npm 与 yarn 的区别是什么？** (有点意思，上次我遇见了这个问题，但没法完全想出来) 不同的包管理工具
5. **tsconfig.json 有什么用？** 关于 ts 的配置文件？
6. **如何配置 TS 编译器？**

#### 2-2 配置 React 开发环境

> 1. 啥是 npx？
>    [阮一峰老师的博文](https://www.ruanyifeng.com/blog/2019/02/npx.html)
>    npm 从 5.2 版开始，增加了 npx 命令
>    （Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。）
>    npx 对标本地安装项目(并非全局安装) 实现多版本控制
>    npx 想要解决的主要问题，就是调用项目内部安装的模块
>    npx 会自动查找当前依赖包(node_modules)中的可执行文件，如果找不到，就会去 PATH 里找
>    npx 的原理很简单，就是运行的时候，会到 node_modules/.bin 路径和环境变量$PATH 里面，检查命令是否存在。
>    npx 还可以避免全局安装模块 npx 将 create-react-app 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 create-react-app。(远古时期，首先使用命令行 npm i -g create-react-app 把工具全局安装在你电脑里 然后通过 create-react-app my-app 来创建 react 项目)

> 2. 无论是 npm start 自动打开页面，还是实时刷新页面 其实估计他们在本质上都是通过 webpack 来实现的

#### 2-3 使用 create-react-app 快速搭建 React

1. package.json 里面的 `dependencies`属性。 这是我们的项目依赖，会展示我们在此项目中安装的所有第三方的组件。 可以看到在创建 react 项目的时候，有三个组件非常显眼： react、react-dom、react-script(这三个组件对应发挥的作用有待思考)
2. 两个重点文件夹
   `public` 文件夹：存放的是静态文件(例如 ico、html 页面、png 图片、json 文件、txt 文件)
   `src` 文件夹：存放的源代码，包含基于 es6 规则的`react代码`(这些浏览器是无法直接识别的，需被转化)
   ``
3. ![script四个指令](./imgs/react-script.png)

```
start: 打开本地dev服务器,把react 网站托管到这个本地服务器中
build: 上面提到的src文件夹里的内容需要被webpack打包等系列操作(将es6的语法变为es5的js语法)放置到public文件夹里才能被浏览器识别。如果要做网站部署，那么就可以直接把这个build文件夹复制粘贴到服务器上就可以了。
test:test脚本，顾名思义，就是做单元测试unit test用的 (这个说实话，我还不太了解呀)
eject： 可以帮助我们弹出网站的配置文件，我们就可以自定义配置了(慎重使用，因为会造成不可逆的结构性改变，所以要搭配git的版本回退功能来使用) 似乎这个命令可以看到脚手架的webpack的配置
```

4. 非常具有 react 代表性的写法`jsx`。 在 js 文件(也可以放在 jsx 文件)里写类似 html 格式的代码。这就是 react 项目`独有的`文件格式 (关键句：我们整个 react 项目都是放在一个 html 文件(public 文件夹里的)一个 id 叫做 root 的 div(html 元素)中的)
5. 掌握好 webpack，因为 React 项目上线使用的底层打包工具就是 webpack

#### 2-4 NPM vs YARN

(yarn 是否有优势呢？ 老师回答： 没啥优势，npm5 以前确实是 yarn 比较好，但现在这俩工具没啥区别了)
二者都是包管理工具(还是使用 npm 更舒服点)

#### 2-5 tsconfig.json 详解(这里的内容其实涉及了 webpack，所以 webpack 这里要好好学学才行)

1. 搭建基于 ts 的 react 项目 命令行输入: npx create-react-app my-app-ts --template typescript

2. 初始化 ts 的 react 项目后，其实可以发现，基于 ts 的 react 比 基于 js 的 react 项目多了 `tsconfig.json`文件(还少了一个 package-lock.json 文件，这个文件我不知道是用来干啥的)

3. TS 基础补充

- ts 是 js 的超集
- ts 用来给原生 js 添加静态类型检查
- 与 ES6 一样，目前还无法被主流浏览器直接读取

4. TS 的编译(这里又是和 webpack 相关的知识了！)

- ts 需要编译器：常见的编译器有：ts-loader、 awesome-typescript-loader、以及 babel-loader(对于 create-react-app 这个脚手架工具而言，使用的就是 babel-loader 这个编译器，所以 ts 编译器的配置文件就是 tsconfig.json)

5. tsconfig.json 文件解读(这部分内容非常的重要， 还是跟 webpack 配置有关)

- "noImplicitAny": false, // 加上这句话，就不需要显示地显示变量的类型 any
- "target": "es5" // 这是代码被编译后的目标 js 版本，一般来说，我们需要让它编译为 es5，这样就可以被主流浏览器解读了，如果是 react-native 做手机 app，那么这里的选项可以选择 es6(其实除了 es5、es6),我们还有很多其他常见的选项，ES5、ES6、ES7...
- "lib": ["dom", "dom.iterable", "esnext"] // 这个属性列出了编译期间需要被包括进来的库文件，通过这些库文件，告诉 ts 编译器可以使用哪些功能
- "allowJs": true // 允许混合编译 js 文件
- "esModuleInterop": true // 这个选项允许我们使用 commonjs 的方式 import 默认文件。比如，在没有开启这个选项时，需要这样写才能引用 react: `import * as React from 'react'` 但是当我们开启了这个选项以后，import 方式就与普通的 js 没有区别了，可以写为： `import React from 'react'` (其实这条内容，我没怎么看懂)
- "noEmit":true // 开启这个选项表示当发生错误的时候，编译器不会生成 js 代码
- "jsx": "react" // 显而易见，这个选项允许编译器支持编译 react 代码
  ...

#### 2-7 深挖 TS 编译流程

对于我们的项目，首先我们用 create-react-app 脚手架创建了 react 项目，启动了 webpack，然后，webpack 中使用了 babel-loader 来编译 ts 文件；最后，在编译的同时根据 tsconfig.json 来配置编译信息

- 将之前的基于原生 js 的 react 项目变为基于 ts 的 react 项目该如何操作呢

```
1. 在项目的根目录下，安装： npm install --save typescript @types/node @types/react @types/react-dom @types/jest

2. 打开根目录下的src文件夹，把所有js或者jsx结尾的文件后缀通通改为tsx，接着回到命令行，运行npm install 确保依赖安装完成
```

**带着问题来学习**

1. 什么是 React? React 是当前前端最流行的 3 大框架之一，本质上是基于 js 的一个 ui 库
2. React 有什么特点？优势、劣势是什么？ 数据单向流动，jsx 语法，函数式编程，虚拟 dom，组件化。 优势是组件化，便于项目管理，以及特别的 jsx 语法让项目 js 和 html 相结合。 劣势是学习成本较大
3. 什么是 jsx?为什么浏览器无法读取 jsx?
4. 什么是虚拟 dom？
5. 什么是组件？
6. state 和 props 的区别有哪些？
7. React 组件的生命周期有哪些阶段？

#### 3-3 【理解】React 的前世今生

1. 零几年的时候 ajax 以及 jQuery 的出现，可以使 js 动态操作 dom 元素以及解决浏览器的兼容性问题(但是随着项目越来越复杂以及需求越来越多样化，维护成本越来越高，我们不仅要简化代码，更需要设计模式！！ 2010 年，第一代 angularJS 带着 mvc 的设计理念横空出世。又是一次前端的蓬勃发展，但是 angularjs 有个天生缺陷即`数据双向绑定`，因为双向数据绑定，导致网站运行速度越来越慢，同时，mvc 架构也带了了网页状态管理混乱的问题。尽管如此，但第一代的 angularJS 带来了一个网站设计思想即`组件化`(组件化就相当于把每个网页才分成若干独立的`模块`(又是模块，跟 webpack 又扯上关系了) 这就意味着你的网站可以被轻易复制和管理。))顺应着组件化的思想，就诞生了我们今天所熟知的`angular`、`reactjs`、`vuejs`等一系列前端框架(这三大框架都是蕴含了组件化的思维吗？)，以及产生了`flex`、`redux`、`mobx`、`immutable`、`observerable`等一些列状态管理的思想。

2. React 的成功基于 3 个独特的设计理念：

   - 单向数据流
   - 虚拟 DOM
   - 组件化

---

[React 设计中的闪光点](https://zhuanlan.zhihu.com/p/28562066)
**【单向数据流】**
数据与界面绑定是非常重要的，通过数据的变化来动态改变页面的显示，这种方式可以极大的减轻前端开发的压力。 但是如何解决 UI 和数据同步呢？ 第一代的 angularJS 引入了双向数据绑定的概念，数据的变化会改变 ui，但是操作 ui 也会影响数据(出现的问题：整个项目越发臃肿，数据也越来越不可控)。 React 对于数据的处理就更加聪明了，不仅选择单向数据流，也选择了另外一条完全不同的方向：单向渲染 --> React 就像一个没有副作用的函数，忠实地根据数据输入来建立符合预期的 UI (通过数据来展示 ui)

**【虚拟 DOM】**
如果说单向渲染是 React 的内核思想，那么虚拟 DOM 就是能够让这个思想得以实现的关键性技术。 在 JS 和 DOM 之间增加一个新的抽象 ui 层，在真实 UI 需要更新时，react 会对比这两个 ui 层，最终以最小的代价差量更新 ui 的元素

**【组件化】**
组件化，就像是搭积木，每一块积木就是一个组件，及既独立又统一，可以自由组合组件！这样就更有助于保持交互一致性、保持视觉风格的统一、便于程序员相互之间的协作

#### 3-4 【组件化】初识 React 函数式组件

1. React 项目初始化后，几个经典的组件介绍：

> App.tsx 组件(src 文件夹下的)
> 这个文件里的 App 组件是一个函数式组件。现在先通过 ts 来研究一下 App 函数的类型
> ![函数式组件](./imgs/函数式组件.png)
> 可见，返回类型是 JSX 元素(也只能是 JSX，不能是其他类型)。 我们可以得到一个结论**只要返回的是 jsx 对象，那么就是一个合法的 react 组件**

2. 假数据似乎都是取名为 mock， 数据似乎基本上都是以 json 文件的格式来进行存放的(这样是更方便解析吗？)

3. 有一个疑问：如果把 mockData 文件夹放在 src 源文件夹外，src 内的文件如(App.tsx 文件还访问不到，这是怎么一回事呢？)

4. 这里很优秀，项目把需要的组件放在一个专门存储组件的文件夹里(components 文件夹 需放在 src 文件夹下)

5. 在一个文件里写一个最简单的函数式组件
   ![函数式组件骨架](./imgs/函数式组件的基本骨架.png)
   (值得注意的是，需要返回 jsx 而不是其他类型)

6. props 的概念 即通过 props 来传递组件之间的数据

7. 给函数组件加类型定义 例如 const Robot:React.FC = (props) => ...
   如果没有 React.FC,则需要给 props 加上指定的类型。

   FC = function component 函数式组件

   鼠标指向 React.FC 显示

   ```
   type React.FC<P = {}> = React.    FunctionComponent<P>
   泛型参数P = props   默认为{}(空对象)
   ```

8. 自定义接口，结合 React.FC 来给 props 定义类型

```
// 创建一个接口
interface RobotProps {
  id: string,
  name: string,
  email: string
}
const Robot : React.FC<RobotProps> = (props) =>...
这时候，props的类型自动绑定为 RobotProps。
```

如果不结合 React.FC 则应该用如下方法给 props 定义类型

```
interface RobotProps {
  id: string,
  name: string,
  email: string
}

const Robot = (props: RobotProps) =>...
```

9. 利用 es6 的语法(注意！react 中是允许写 es6 语法的)花括号来展开参数，让代码更简洁...

```
旧：
interface RobotProps {
  id: string,
  name: string,
  email: string
}
const Robot : React.FC<RobotProps> = (props) => {
  return <>
    const id = props.id
  </>
}

新：
interface RobotProps {
  id: string,
  name: string,
  email: string
}
const Robot : React.FC<RobotProps> = ({id, name, email}) => {
  return <>
    id... // 直接使用
  </>
}
```

10. 注意，在 JSX 语法中你可以在`大括号`里放置任何有效的 js 表达式

11. 关于大括号的问题：

```
    <ul>
      {robots.map(robot => {
        // 为什么这里robot.xx也要用{}来包裹呢？
        <Robot id={robot.id} email={robot.email} name={robot.name}/>
      })}
    </ul>
  );

  3-5 第3点有讲解！   用括号是因为插入的是一个js表达式
```

#### 3-5【概念理解】JSX 编程思维

1. JSX 是 ReactJS 自创的语言(既不是 js 也不是 html 或者理解为即是 js 又是 html) 但是 JSX 是具有 JS 的全部功能的

2. 首先要明确一件事情，React 并未强制开发者使用 JSX，程序员可以选择用纯粹的 js 的方法，调用 react 的 api 来实现 react 项目。 但是使用 JSX 可以在视觉上有辅助作用，并且可以显示更多有用的错误或者警告信息。但这些都并不是使用 jsx 的理由。**为啥要使用 JSX？** 在 react 的认识里，ui 视图的本质就是渲染逻辑与 ui 视图表现的内在统一。**将 html 与逻辑想结合(渲染逻辑与 UI 视图的耦合)，这就是 JSX**

3. **【JSX 的特点】**
   (JSX 既能写 html，又能写 js)

   - 常规的 html 代码都可以与 JSX 兼容。比如，html 中的 h1 元素、div 元素、button 元素等
   - 可以在 JSX 中嵌入 JS 表达式(需要被包裹在大括号里面)
   - 使用 JSX 指定子元素？
   - 因为 JSX 语法更接近 js 而不是 html，所以 react 在命名规范上使用驼峰命名(注意：JSX 里的 class 变成 className, 而 tabindex 变为 tabIndex)
   - JSX 也是一个表达式，在编译之后，JSX 表达式会被转为普通 JS 函数调用，并且对其取值后得到 JS 对象，也就是说，你可以再 if 语句和 for 循环的代码块中使用 jsx，将 jsx 赋值给变量，把 jsx 当作参数传入，以及从函数中返回 JSX
   - **JSX 特定属性** 你可以通过使用引号，来将属性值指定为字符串字面量 `const element = <div tabIndex='0'></div>;` 也可以使用大括号，来在属性值中插入一个 JS 表达式： `const element = <img src={uer.avatarUrl}></img>;`
   - jsx 的自定义属性，以 data-开头 `const element = <div data-customized={'自定义属性'}></div>;`

4. **使用 JSX 指定元素**
   假如一个标签里面没有内容(没有再嵌套标签啥的)，你可以使用 `/>` 来闭合标签，就像 XML 语法一样。
   `const element = <img src={...} />;`
   JSX 标签里能够包含很多子元素：
   ```
    const element = (
      <div>
        <h1>Hello!</h1>
        <h2>Good to see you here.</h2>
      </div>
    );
   ```
5. **JSX 防止注入攻击** 使用花括号直接引用渲染内容的时候，React 会自动转义(但是人家只要输入一个函数，同样会被 xss 注入攻击的)
6. JSX 表示对象
   JSX 会被编译为 React.createElement()对象

```
const element = (
  <h1 className='greeting'>
  Hello, world!
  </h1>
)

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
这两种写法的效果是一样的，最后输出的对象如下：
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
```

#### 3-6 【组件化】配置 React 的 css 模组

1. 在 React 中使用 css 文件 可以选择把 css 文件和 component 文件放在同一个目录下。比如： Robot.module.css Robot.tsx

2. React 最大的优势是`组件化`,即每个 jsx 或者 tsx 文件被视为一个独立存在的原件。我们使用一个简简单单的 import 关键词，来 import 整个 css 文件，那么将会直接引入整个文件，而不是`按需加载`。这样的操作可能会在成全局污染。 所以，我们应该把 import 一个 css 文件换成 import 这个 css 对象，通过访问对象来独立加载组件样式

   > import './index.css';
   > import style from './index.css'

3. 注意一个问题！在 ts 的 react 项目中，无法识别 css 格式文件(即 import style ...无法识别) 需要给 css 文件加上类型的定义配置

4. 在 ts 中，类型的定义要用*.d.ts 为后缀的文件表示，*.d.ts 是 ts 专用的声明类型的文件(只包含类型声明，不包含任何逻辑，不会被编译、不会被 webpack 打包)声明方法如下：

```
declare module "*.css" {
	const css: { [key: string]: string };
	export default css;
}
```

5. **【css 文件的引入】**
   有两种方法：
   方法一： 直接引入整个 css 文件

```
import './index.css'
//使用方式
<div className="app"></div>

```

方法二： 利用 CSS in JS，把 css 转化为对象，通过对象的方式，模块化引入组件

```
import styles from "./App.module.css";
//使用方式
<div className={styles.app}></div>

```

从组件化的角度上来说，使用第二种方式`CSS in JS`会更加贴合 React `组件独立`的原则

6. **利用 TS 给 CSS 加上类型**
   实现步骤：

   > 1.安装插件：npm i typescript-plugin-css-modules --save-dev (因为不参与上线，所以放在 dev 依赖中)

   > 2. 打开 tsconfig.json,来注册、启用这个插件： "plugins": [{ "name": "typescript-plugin-css-modules" }]。

> 3. 在根目录下创建.vscode 的文件夹，这个文件夹是用来处理 vs code 配置的，添加文件 settings.json,然后在文件中输入这么一段话

```
{
"typescript.tsdk": "node_modules/typescript/lib",
"typescript.enablePromptUseWorkspaceTsdk": true
}
```

这时候，我们的编译器就可以对 css 也有只能提示功能了

7. 区分 dev 依赖项和普通的依赖：
   dev 依赖(devDependencies)就是指哪些仅参与代码开发，而不参与最终上线打包的项目，比如 typescript、babel-loader 等

#### 3.7 【资源配置】加载媒体与字体文件

1. 注意，create-react-app 这个脚手架已经帮助我们配置好了各种媒体资源的加载工具(其实自己把 webpack 学会后，自己也可以尝试一下弄弄这些)

2. **文件管理：** 一般来说，网站的静态资源我们都会统一保存在同一个文件夹中，这样方便我们进行统一的管理。命名约定一般为`assets`,然后在这个大文件里，分别创建`font`、`imgs`、`icon`文件夹来分别放对应的文件。

```
src
 |-assets
      |- imgs
      |- fonts
      |- icons
```

3. 字体下载
   目前我已知的给 React 项目全局加载字体的方法有两种
   1. 首先在 google font：https://fonts.google.com (需要翻墙)里找到合适的字体:
      ![谷歌字体1](./imgs/googleFont1.png) 然后把红线勾中的部分放进 public/index.html 里面，就可以实现全局字体的使用了。如图： ![谷歌字体2](./imgs/googleFont2.png) 这样就能实现全局注入新的字体的效果了！
   2. 首先在搜索引擎搜索免费字体(随便推荐一个：https://www.fonts.net.cn/fonts-zh-1.html)： 下载之后，会得到一个 ttf 为后缀的字体文件(把这个文件放进 assets/fonts 文件夹里)，在 src/index.css 文件下配置文件。 如下图： ![字体font-face](./imgs/font-face1.png)。 之后，如果要使用该字体，直接 font-family 定义的名字即可：![字体font-face](./imgs/font-face2.png)
